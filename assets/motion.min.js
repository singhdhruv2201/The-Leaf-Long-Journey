(function(global){
  // Minimal Motion One shim using the Web Animations API.
  // Provides `window.motion.animate(targets, keyframes, options)`.
  // - targets: Element | Element[] | NodeList
  // - keyframes: { prop: [v0, v1, ...], ... } or Array-like WA keyframes
  // - options: { duration, delay, easing, ... } (duration/delay in seconds if < 30)

  function toArray(t){
    if (!t) return [];
    if (Array.isArray(t)) return t;
    if (NodeList.prototype.isPrototypeOf(t)) return Array.from(t);
    return [t];
  }

  function isPlainKeyframes(obj){
    return obj && typeof obj === 'object' && !Array.isArray(obj) && !('offset' in obj);
  }

  function assembleKeyframes(kf){
    if (!isPlainKeyframes(kf)) return kf; // assume already an array of frames
    // Determine max length across properties
    const props = Object.keys(kf);
    let maxLen = 0;
    props.forEach(p => { const v = kf[p]; if (Array.isArray(v)) maxLen = Math.max(maxLen, v.length); else maxLen = Math.max(maxLen, 1); });
    if (maxLen === 0) maxLen = 1;

    const transformProps = new Set(['translateX','translateY','translateZ','x','y','z','scale','scaleX','scaleY','rotate']);

    const frames = [];
    for (let i=0;i<maxLen;i++){
      const frame = {};
      const transforms = [];
      props.forEach(p => {
        let arr = kf[p];
        const val = Array.isArray(arr) ? (i < arr.length ? arr[i] : arr[arr.length-1]) : arr;
        if (val === undefined) return;
        if (transformProps.has(p)){
          if (p === 'x' || p === 'translateX') transforms.push(`translateX(${addUnit(val)})`);
          else if (p === 'y' || p === 'translateY') transforms.push(`translateY(${addUnit(val)})`);
          else if (p === 'z' || p === 'translateZ') transforms.push(`translateZ(${addUnit(val)})`);
          else if (p === 'scale') transforms.push(`scale(${val})`);
          else if (p === 'scaleX') transforms.push(`scaleX(${val})`);
          else if (p === 'scaleY') transforms.push(`scaleY(${val})`);
          else if (p === 'rotate') transforms.push(`rotate(${ensureUnit(val,'deg')})`);
          else transforms.push(`${p}(${val})`);
        } else if (p === 'transform'){
          // use directly
          frame.transform = val;
        } else {
          // map shorthand y/x to translateY/X handled above; otherwise set property as-is
          frame[toCssProp(p)] = val;
        }
      });
      if (transforms.length){
        frame.transform = transforms.join(' ');
      }
      frames.push(frame);
    }
    return frames;
  }

  function toCssProp(prop){
    // simple camelCase -> kebab-case
    return prop.replace(/([A-Z])/g, '-$1').toLowerCase();
  }

  function ensureUnit(v, unit){
    return (typeof v === 'number') ? `${v}${unit}` : v;
  }
  function addUnit(v){
    if (typeof v === 'number') return `${v}px`;
    return v;
  }

  function normalizeOptions(opts){
    if (!opts) return { duration: 300, easing: 'ease', fill: 'forwards' };
    const o = Object.assign({}, opts);
    // If duration is given and looks small (< 30), treat as seconds
    if (o.duration && o.duration > 0 && o.duration < 30) o.duration = o.duration * 1000;
    if (o.delay && o.delay > 0 && o.delay < 30) o.delay = o.delay * 1000;
    // fallback easing for spring-ish strings
    if (typeof o.easing === 'string' && o.easing.startsWith('spring')) o.easing = 'cubic-bezier(.2,.9,.22,1)';
    // Web Animations API recognizes `easing`, `duration`, `delay`, `fill` etc.
    o.fill = o.fill || 'forwards';
    return o;
  }

  function animateSingle(el, keyframes, options){
    if (!el || !el.animate) return Promise.resolve();
    const frames = assembleKeyframes(keyframes);
    const opts = normalizeOptions(options);
    try {
      const anim = el.animate(frames, opts);
      return anim.finished.catch(() => {});
    } catch (e){
      // if frames were already an array, try using them directly
      try {
        const anim2 = el.animate(keyframes, opts);
        return anim2.finished.catch(() => {});
      } catch (err){
        return Promise.resolve();
      }
    }
  }

  function animate(targets, keyframes, options){
    const els = toArray(targets);
    if (els.length === 0) {
      const p = Promise.resolve();
      p.finished = p;
      return p;
    }
    // If targets is an array, animate each and return composite
    const promises = els.map(el => animateSingle(el, keyframes, options));
    // finished is a Promise that resolves when all animations complete
    const finished = Promise.all(promises);
    // Return a thenable Promise so callers can `await motion.animate(...)`
    const ret = new Promise((resolve, reject) => {
      finished.then(resolve).catch(reject);
    });
    // Expose the finished promise for compatibility (.finished)
    ret.finished = finished;
    return ret;
  }

  // Expose minimal API
  global.motion = global.motion || {};
  global.motion.animate = animate;
  // small helper: set() to instantly apply styles
  global.motion.set = function(targets, props){
    toArray(targets).forEach(el => {
      if (!el || !el.style) return;
      Object.keys(props).forEach(k => {
        const v = props[k];
        if (k === 'x' || k === 'y') {
          const cur = el.style.transform || '';
          const tr = (k === 'x') ? ` translateX(${addUnit(v)})` : ` translateY(${addUnit(v)})`;
          el.style.transform = (cur + tr).trim();
        } else if (k === 'opacity') el.style.opacity = v;
        else el.style[toCssProp(k)] = v;
      });
    });
  };

  // Tell devs
  console.info('motion shim loaded (minimal)');
})(window);
